# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox
import PyQt5

import pandas as pd
from datetime import datetime, timezone
import numpy as np
import geopy.distance
from scipy.signal import butter, filtfilt
import cv2
import os

N = 4
Fc = .5
Fs = 10
Wn = Fc/Fs
b, a = butter(N, Wn, 'low')

streering_func = np.poly1d([-481.62457676, 5519.05946954, -20719.85044531, 25454.9924588])

script_path = os.path.abspath(__file__)
script_directory = os.path.dirname(script_path)


def get(a):
    return str(int(float(a)))

def utc_ms_gen(tab, index):
    t_s = '20' + get(tab.loc[index, 'TimeYear'])
    t_s += '-' + get(tab.loc[index, 'TimeMonth'])
    t_s += '-' + get(tab.loc[index, 'TimeDay'])
    t_s += ' ' + get(tab.loc[index, 'TimeHour'])
    t_s += ':' + get(tab.loc[index, 'TimeMinute'])
    t_s += ':' +str(round(float(tab.loc[index, 'TimeSecond'])+float(tab.loc[index, 'TimeHSecond']),2))
    datetime_obj = datetime.strptime(t_s, "%Y-%m-%d %H:%M:%S.%f")
    datetime_utc_ms = int(datetime_obj.replace(tzinfo=timezone.utc).timestamp() * 1000)
    return int(datetime_utc_ms)

def find_first_match(lst, condition):
    for index, item in enumerate(lst):
        if condition(item):
            return index, item
    return None, None # Return None if no match is found

def find_last_match(lst, condition):
    for index, item in reversed(list(enumerate(lst))):
        if condition(item):
            return index, item
    return None, None

def find_best_match(x_ls, y_ls, x0):
    index,_ = find_first_match(x_ls, lambda x: float(x) >= x0)
    if index is None:
        return None
    P0 = (float(x_ls[index-1]), float(y_ls[index-1]))
    P1 = (float(x_ls[index]), float(y_ls[index]))
    return (P1[1]-P0[1])/(P1[0]-P0[0])*(x0-P0[0])+P0[1]

def min_search(x, y, x0, y0):
    d = np.sqrt((x - x0)**2 + (y - y0)**2)
    min_index = np.argmin(d)
    P1 = (x[min_index], y[min_index])
    try:
        P0 = (x[min_index-1], y[min_index-1])
    except:
        P0 = (x[len(x)-1], y[len(x)-1])
    s = np.sign((P1[0] - P0[0]) * (y0 - P0[1]) - (P1[1] - P0[1]) * (x0 - P0[0]))
    d = geopy.distance.geodesic(P1, (x0, y0)).m
    return d*s

def classify_image(frame, i=0):
    frame = cv2.resize(frame, (1600, 900))
    frame = frame[40:47,230:320]
    if i > 0:
        cv2.imwrite(f'New/{i}.png', frame)
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    color_ranges = {
        "white": ([200, 200, 200], [255, 255, 255]),  # Light colors
        "orange": ([200, 100, 0], [255, 180, 100]),   # Orange tones
        "blue": ([0, 0, 100], [100, 150, 255]),       # Blue tones
    }
    color_counts = {color: 0 for color in color_ranges.keys()}
    for color, (lower, upper) in color_ranges.items():
        lower = np.array(lower, dtype="uint8")
        upper = np.array(upper, dtype="uint8")
        mask = cv2.inRange(frame, lower, upper)
        color_counts[color] += cv2.countNonZero(mask)

    dominant_color = max(color_counts, key=color_counts.get)
    if dominant_color=='orange':
        return True
    else:
        return False

class Ui_Dialog(object):
    def __init__(self):
        self.vbo_received = False
        self.str_received = False

    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(713, 449)
        self.logo = QtWidgets.QLabel(Dialog)
        self.logo.setGeometry(QtCore.QRect(0, 0, 731, 81))
        self.logo.setText("")
        self.logo.setPixmap(QtGui.QPixmap(os.path.join(script_directory,"logo.jpg")))
        self.logo.setScaledContents(True)
        self.logo.setObjectName("logo")
        self.vbo = QtWidgets.QGroupBox(Dialog)
        self.vbo.setGeometry(QtCore.QRect(20, 90, 671, 101))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.vbo.setFont(font)
        self.vbo.setObjectName("vbo")
        self.vbo_pwd = QtWidgets.QLabel(self.vbo)
        self.vbo_pwd.setGeometry(QtCore.QRect(20, 40, 541, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.vbo_pwd.setFont(font)
        self.vbo_pwd.setObjectName("vbo_pwd")
        self.browse_vbo_but = QtWidgets.QPushButton(self.vbo)
        self.browse_vbo_but.setGeometry(QtCore.QRect(580, 40, 71, 41))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.browse_vbo_but.setFont(font)
        self.browse_vbo_but.setObjectName("browse_vbo_but")
        self.str = QtWidgets.QGroupBox(Dialog)
        self.str.setGeometry(QtCore.QRect(20, 200, 671, 101))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.str.setFont(font)
        self.str.setObjectName("str")
        self.str_pwd = QtWidgets.QLabel(self.str)
        self.str_pwd.setGeometry(QtCore.QRect(20, 40, 531, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.str_pwd.setFont(font)
        self.str_pwd.setObjectName("str_pwd")
        self.browse_str_but = QtWidgets.QPushButton(self.str)
        self.browse_str_but.setGeometry(QtCore.QRect(580, 40, 71, 41))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.browse_str_but.setFont(font)
        self.browse_str_but.setObjectName("browse_str_but")
        self.report = QtWidgets.QGroupBox(Dialog)
        self.report.setGeometry(QtCore.QRect(20, 310, 401, 131))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.report.setFont(font)
        self.report.setObjectName("report")
        self.report_label = QtWidgets.QLabel(self.report)
        self.report_label.setGeometry(QtCore.QRect(20, 30, 361, 91))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.report_label.setFont(font)
        self.report_label.setObjectName("report_label")
        self.process_but = QtWidgets.QPushButton(Dialog)
        self.process_but.setGeometry(QtCore.QRect(540, 320, 101, 51))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.process_but.setFont(font)
        self.process_but.setObjectName("process_but")
        self.conv_but = QtWidgets.QPushButton(Dialog)
        self.conv_but.setGeometry(QtCore.QRect(430, 320, 101, 51))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.conv_but.setFont(font)
        self.conv_but.setObjectName("conv_but")
        self.lka_but = QtWidgets.QPushButton(Dialog)
        self.lka_but.setGeometry(QtCore.QRect(430, 380, 101, 51))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.lka_but.setFont(font)
        self.lka_but.setObjectName("lka_but")
        self.warn_but = QtWidgets.QPushButton(Dialog)
        self.warn_but.setGeometry(QtCore.QRect(540, 380, 101, 51))
        font = QtGui.QFont()
        font.setPointSize(12)
        font.setBold(True)
        font.setWeight(75)
        self.warn_but.setFont(font)
        self.warn_but.setObjectName("warn_but")

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        self.browse_vbo_but.clicked.connect(self.actionOpen_File_VBO)
        self.browse_str_but.clicked.connect(self.actionOpen_File_STR)
        self.process_but.clicked.connect(self.actionProcess)
        self.conv_but.clicked.connect(self.actionConv)
        self.lka_but.clicked.connect(self.actionLKA)
        self.warn_but.clicked.connect(self.actionWarn)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Post-Processing Tool"))
        self.vbo.setTitle(_translate("Dialog", "VBOX "))
        self.vbo_pwd.setText(_translate("Dialog", "Select log File"))
        self.browse_vbo_but.setText(_translate("Dialog", "Browse"))
        self.str.setTitle(_translate("Dialog", "Soft Target Robot"))
        self.str_pwd.setText(_translate("Dialog", "Select log File"))
        self.browse_str_but.setText(_translate("Dialog", "Browse"))
        self.report.setTitle(_translate("Dialog", "Report"))
        self.report_label.setText(_translate("Dialog", ""))
        self.process_but.setText(_translate("Dialog", "AEB Sync"))
        self.conv_but.setText(_translate("Dialog", "VBO to CSV"))
        self.lka_but.setText(_translate("Dialog", "LKA Proc"))
        self.warn_but.setText(_translate("Dialog", "Warning"))

    def actionOpen_File_VBO(self):
        temp = QtWidgets.QFileDialog.getOpenFileName(caption='Select *.vbo file', filter='vbo(*.vbo)')
        if temp and temp[0][-4:]=='.vbo':
            self.VBO_FILE_NAME = temp[0]
            self.vbo_received=True
            self.vbo_pwd.setText(QtCore.QCoreApplication.translate("Dialog", self.VBO_FILE_NAME))
        else:
            # msg = QMessageBox()
            # msg.setWindowTitle("Image Found")
            # msg.setText(f"{len(self.IMG_LIST)} images found!")
            # msg.setIcon(QMessageBox.Information)
            # msg.exec_()
            self.vbo_received = False

    def actionOpen_File_STR(self):
        temp = QtWidgets.QFileDialog.getOpenFileName(caption='Select *.csv file', filter='csv(*.csv)')
        if temp and temp[0][-4:]=='.csv':
            self.RST_FILE_NAME = temp[0]
            self.rst_received=True
            self.str_pwd.setText(QtCore.QCoreApplication.translate("Dialog", self.RST_FILE_NAME))
        else:
            # msg = QMessageBox()
            # msg.setWindowTitle("Image Found")
            # msg.setText(f"{len(self.IMG_LIST)} images found!")
            # msg.setIcon(QMessageBox.Information)
            # msg.exec_()
            self.rst_received = False

    def actionProcess(self):
        if not (self.rst_received and self.vbo_received):
            return 
        secs=[]
        with open(self.VBO_FILE_NAME, 'r') as f:
            for i, l in enumerate(f):    
                if '[' in l:
                    header = secs.append((l, i))


        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'column names' in sec[0]:
                    cols = f.readlines()[sec[1]+1].split(' ')[:-1]
                    
        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'data' in sec[0]:
                    lines = f.readlines()[sec[1]+1:]

        df = []
        for l in lines:
            df.append(list(l[:-1].split(' ')))
        vbo = pd.DataFrame(df, columns=cols)
        utc_list = []
        for i in range(len(vbo)):
            utc_list.append(utc_ms_gen(vbo, i))
        vbo['UTC_Time'] = utc_list
        stride = pd.read_csv(self.RST_FILE_NAME)

        coords_trigger = (42.2421774, -83.5485989)
        relDistance = []
        for i in range(len(vbo)):
            coord = (float(vbo.loc[i, 'PosLat'])*1e-7, float(vbo.loc[i, 'PosLon'])*1e-7)
            relDistance.append((geopy.distance.geodesic(coords_trigger, coord).m)*np.sign(coords_trigger[1]-coord[1]))
        vbo['relDistance'] = ['{:010.4f}'.format(i) for i in relDistance]

        diff = np.abs(stride.loc[0, 'utc_time(ms)']/1000.0-vbo.loc[0, 'UTC_Time']/1000.0)
        if diff > 1:
            msg = QMessageBox()
            msg.setWindowTitle("Data mistmatch!")
            msg.setText(f"Measured time offset is larger than 1s ({diff}s)\nWould you like to continue?")
            msg.setIcon(QMessageBox.Question)
            msg.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
            msg.setDefaultButton(QMessageBox.Yes)
            result = msg.exec_()
            if result == QMessageBox.No:
                return

        index, _ = find_first_match(stride['pressure_switch'], lambda x: x == 1)
        ts = stride.loc[index, 'utc_time(ms)']
        index, _ = find_first_match(vbo['relDistance'], lambda x: float(x) >= 0)
        tv = vbo.loc[index, 'UTC_Time']
        stride['utc_time(ms)'] += tv-ts

        index, _ = find_first_match(stride['pressure_switch'], lambda x: x == 1)
        t0 = stride.loc[index, 'utc_time(ms)']
        index,_ = find_first_match(vbo['UTC_Time'], lambda x: float(x) >= t0)
        P0 = (float(vbo.loc[index-1, 'UTC_Time']), float(vbo.loc[index-1, 'relDistance']))
        P1 = (float(vbo.loc[index, 'UTC_Time']), float(vbo.loc[index, 'relDistance']))
        v0 = (P1[1]-P0[1])/(P1[0]-P0[0])*(t0-P0[0])+P0[1]
        rel_dist = [float(i)-v0 for i in vbo['relDistance']]
        vbo['relDistance'] = ['{:010.4f}'.format(i) for i in rel_dist]

        # coords_trigger = (42.2422311, -83.5482209)
        cords = []
        for i in range(len(stride)):
            cords.append((stride.loc[i, 'latitude(deg)'], stride.loc[i, 'longitude(deg)']))

        dist = []
        for cord in cords:
            dist.append(geopy.distance.geodesic(coords_trigger, cord).m)
        stride['distToPS'] = dist

        stride_dist = []
        t = [float(i) for i in stride['utc_time(ms)']]
        y = [float(i) for i in stride['distToPS']]

        for t0 in vbo['UTC_Time']:
            stride_dist.append(find_best_match(t, y, float(t0)))

        stride_vel = []
        z = [float(i) for i in stride['vel_forward(m/s)']]

        for t0 in vbo['UTC_Time']:
            vel = find_best_match(t, z, float(t0))
            if not vel==None: 
                stride_vel.append(vel)
            else:
                stride_vel.append(stride_vel[-1])

        vbo['Target_Vel_Forward'] = ['{:010.4f}'.format(i) for i in stride_vel]

        dist_to_target=[]
        for idx, val in enumerate(vbo['relDistance']):
            try:
                dist_to_target.append(stride_dist[idx]-float(val))
            except:
                dist_to_target.append(dist_to_target[-1])
        vbo['TTC_Range'] = ['{:010.4f}'.format(i) for i in dist_to_target]

        TTC = []
        for i, r in enumerate( vbo['TTC_Range']):
            try:
                TTC.append(float(r)/(float(vbo.loc[i, 'VelForward'])-stride_vel[i]))
            except:
                TTC.append(-1)
        vbo['TTC'] = ['{:010.4f}'.format(i) for i in TTC]

        vbo.to_csv('vbo.csv', sep=' ', header=None, index=None)
        msg = QMessageBox()
        msg.setWindowTitle("Save CSV")
        msg.setText(f"Would you like to save data as CSV?")
        msg.setIcon(QMessageBox.Question)
        msg.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
        msg.setDefaultButton(QMessageBox.Yes)
        result = msg.exec_()
        if result == QMessageBox.Yes:
            NAME = self.VBO_FILE_NAME[:-4] + '_RAW.csv'
            vbo.to_csv(NAME, sep=',', index=None)
            
        TARGET_FILE_NAME = self.VBO_FILE_NAME[:-4]+'_E.vbo'
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_header = f.readlines()[:secs[1][1]-1]
            T_header.append('UTC_Time\n')
            T_header.append('relDistance\n')
            T_header.append('Target_Vel_Forward\n')
            T_header.append('TTC_Range\n')
            T_header.append('TTC\n')
            T_header.append('\n')
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_channel_units = f.readlines()[secs[1][1]:secs[2][1]-1]
            T_channel_units.append('ms\n')
            T_channel_units.append('m\n')
            T_channel_units.append('m/s\n')
            T_channel_units.append('m\n')
            T_channel_units.append('s\n')
            T_channel_units.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_fill = f.readlines()[secs[2][1]:secs[4][1]-1]
            T_fill.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_columns = f.readlines()[secs[4][1]:secs[5][1]+1]
            T_columns[1] = T_columns[1][:-2]+' UTC_Time relDistance Target_Vel_Forward TTC_Range TTC\n'

        with open('vbo.csv', 'r') as f:
            data = f.readlines()

        with open(TARGET_FILE_NAME, 'w') as f:
            for l in T_header:
                f.write(l)
            for l in T_channel_units:
                f.write(l)
            for l in T_fill:
                f.write(l)
            for l in T_columns:
                f.write(l)
            for l in data:
                f.write(l)
        
        msg = QMessageBox()
        msg.setWindowTitle("Accomplished")
        msg.setText('New file:' + TARGET_FILE_NAME)
        msg.setIcon(QMessageBox.Information)
        msg.exec_()

    def actionWarn(self):
        if not (self.vbo_received) or '_E.vbo' not in self.VBO_FILE_NAME:
            return 
        secs=[]
        with open(self.VBO_FILE_NAME, 'r') as f:
            for i, l in enumerate(f):    
                if '[' in l:
                    header = secs.append((l, i))


        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'column names' in sec[0]:
                    cols = f.readlines()[sec[1]+1].split(' ')
        if cols[-1] in [' ', '', '\n']:
                cols = cols[:-1]
                    
        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'data' in sec[0]:
                    lines = f.readlines()[sec[1]+1:]

        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'AVI' in sec[0]:
                    AVI_PATH = f.readlines()[sec[1]+1][:-1] + '0001.mp4'
        AVI_PATH =os.path.dirname(self.VBO_FILE_NAME)+'/'+ AVI_PATH

        df = []
        for l in lines:
            df.append(list(l[:-1].split(' ')))
        vbo = pd.DataFrame(df, columns=cols)
        
        t = []
        w = []
        idx = 1
        cap = cv2.VideoCapture(AVI_PATH)
        while True:
            ret, frame = cap.read()
            if not ret:
                break
            if classify_image(frame):
                w.append(1)
            else:
                w.append(0)
            t.append(cap.get(cv2.CAP_PROP_POS_MSEC))
            idx += 1
        cap.release()
        
        tm = np.array(t) / 1000 - 2.9
        tv = np.array([float(i) for i in vbo['time']])
        tv = np.array(range(len(tv)))*.1
        index, _ = find_first_match(w, lambda x: x == 1)
        if not index==None:
            warn_on, _ = find_first_match(tv, lambda x: x >= tm[index])
            index, _ = find_last_match(w, lambda x: x == 1)
            warn_off, _ = find_first_match(tv, lambda x: x >= tm[index])
            warn = np.array([0 for i in tv])
            warn[warn_on:warn_off] = 1
            vbo['Warning'] = ['{:01.0f}'.format(i) for i in warn]
        else:
            vbo['Warning'] = ['0' for i in tv]
        
        vbo.to_csv('vbo.csv', sep=' ', header=None, index=None)
        msg = QMessageBox()
        msg.setWindowTitle("Save CSV")
        msg.setText(f"Would you like to save data as CSV?")
        msg.setIcon(QMessageBox.Question)
        msg.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
        msg.setDefaultButton(QMessageBox.Yes)
        result = msg.exec_()
        if result == QMessageBox.Yes:
            NAME = self.VBO_FILE_NAME[:-4] + '_RAW.csv'
            vbo.to_csv(NAME, sep=',', index=None)
            
        TARGET_FILE_NAME = self.VBO_FILE_NAME
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_header = f.readlines()[:secs[1][1]-1]
            if not any(['Warning' in a for a in cols]):
                T_header.append('Warning\n')
            T_header.append('\n')
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_channel_units = f.readlines()[secs[1][1]:secs[2][1]-1]
            if not any(['Warning' in a for a in cols]):
                T_channel_units.append('(null)\n')
            T_channel_units.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_fill = f.readlines()[secs[2][1]:secs[4][1]-1]
            T_fill.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_columns = f.readlines()[secs[4][1]:secs[5][1]+1]
            if not any(['Warning' in a for a in cols]):
                T_columns[1] = T_columns[1][:-1]+' Warning\n'

        with open('vbo.csv', 'r') as f:
            data = f.readlines()

        with open(TARGET_FILE_NAME, 'w') as f:
            for l in T_header:
                f.write(l)
            for l in T_channel_units:
                f.write(l)
            for l in T_fill:
                f.write(l)
            for l in T_columns:
                f.write(l)
            for l in data:
                f.write(l)
        
        msg = QMessageBox()
        msg.setWindowTitle("Accomplished")
        msg.setText('New file:' + TARGET_FILE_NAME)
        msg.setIcon(QMessageBox.Information)
        msg.exec_()

    def actionConv(self):
        temp = QtWidgets.QFileDialog.getOpenFileNames(caption='Select *.vbo files', filter='vbo(*.vbo)')
        if not temp:
            return
               
        for VBO_FILE_NAME in temp[0]:
            secs=[]
            with open(VBO_FILE_NAME, 'r') as f:
                for i, l in enumerate(f):    
                    if '[' in l:
                        header = secs.append((l, i))


            with open(VBO_FILE_NAME, 'r') as f:
                for sec in secs:
                    if 'column names' in sec[0]:
                        cols = f.readlines()[sec[1]+1].split(' ')
            if cols[-1] in [' ', '', '\n']:
                cols = cols[:-1]
                        
            with open(VBO_FILE_NAME, 'r') as f:
                for sec in secs:
                    if 'data' in sec[0]:
                        lines = f.readlines()[sec[1]+1:]

            df = []
            for l in lines:
                df.append(list(l[:-1].split(' ')))

            vbo = pd.DataFrame(df, columns=cols)
            utc_list = []
            for i in range(len(vbo)):
                utc_list.append(utc_ms_gen(vbo, i))
            vbo['UTC_Time'] = utc_list

            NAME = VBO_FILE_NAME[:-4] + '_RAW.csv'
            vbo.to_csv(NAME, sep=',', index=None)
            
        msg = QMessageBox()
        msg.setWindowTitle("Accomplished")
        msg.setText(f'{len(temp[0])} files have been converted')
        msg.setIcon(QMessageBox.Information)
        msg.exec_()

    def actionLKA(self):
        if not self.vbo_received:
            return
        offset_left = 3.468828596984335
        offset_right = -0.22167041440278953

        msg = QMessageBox()
        msg.setWindowTitle("Lane Select")
        msg.setText(f"Test is on ACM Highway Loop's right (outer) lane?")
        msg.setIcon(QMessageBox.Question)
        msg.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
        msg.setDefaultButton(QMessageBox.Yes)
        result = msg.exec_()
        if result == QMessageBox.Yes:
            offset = offset_right
        else:
            offset = offset_left

        secs=[]
        with open(self.VBO_FILE_NAME, 'r') as f:
            for i, l in enumerate(f):    
                if '[' in l:
                    header = secs.append((l, i))


        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'column names' in sec[0]:
                    cols = f.readlines()[sec[1]+1].split(' ')[:-1]
                    
        with open(self.VBO_FILE_NAME, 'r') as f:
            for sec in secs:
                if 'data' in sec[0]:
                    lines = f.readlines()[sec[1]+1:]

        df = []
        for l in lines:
            df.append(list(l[:-1].split(' ')))
        vbo = pd.DataFrame(df, columns=cols)
        utc_list = []
        for i in range(len(vbo)):
            utc_list.append(utc_ms_gen(vbo, i))
        vbo['UTC_Time'] = utc_list
        
        calib = pd.read_csv('Highway Loop Right Lane 11-4-2022.csv')
        d = []
        for i in range(len(vbo)):
            coord = (float(vbo.loc[i, 'PosLat'])*1e-7, float(vbo.loc[i, 'PosLon'])*1e-7)
            d.append(min_search(calib['Latitude (deg)'], calib[' Longitude (deg)'], coord[0], coord[1]))
        
        vbo['OffsetToCL'] = ['{:010.4f}'.format(i + offset) for i in d]
        vbo['OffsetToCL_filt'] = ['{:010.4f}'.format(i + offset) for i in filtfilt(b, a, d)]

        accel_lat = [float(i) for i in vbo['AccelLateral']]
        vbo['AccelLateral_filt'] = ['{:010.4f}'.format(i) for i in filtfilt(b, a, accel_lat)]


        if 'Channel_1' in vbo.columns:
            steering = [streering_func(float(i)) for i in vbo['Channel_1']]
            vbo['Steering_Angle'] = ['{:010.4f}'.format(i) for i in filtfilt(b, a, steering)]

        vbo.to_csv('vbo.csv', sep=' ', header=None, index=None)
        TARGET_FILE_NAME = self.VBO_FILE_NAME[:-4]+'_E.vbo'
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_header = f.readlines()[:secs[1][1]-1]
            T_header.append('UTC_Time\n')
            T_header.append('OffsetToCL\n')
            T_header.append('OffsetToCL_filt\n')
            T_header.append('AccelLateral_filt\n')
            if 'Channel_1' in vbo.columns:
                T_header.append('Steering_Angle\n')
            T_header.append('\n')
        with open(self.VBO_FILE_NAME, 'r') as f:
            T_channel_units = f.readlines()[secs[1][1]:secs[2][1]-1]
            T_channel_units.append('ms\n')
            T_channel_units.append('m\n')
            T_channel_units.append('m\n')
            T_channel_units.append('m/sÂ²\n')
            if 'Channel_1' in vbo.columns:
                T_channel_units.append('Â°\n')
            T_channel_units.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_fill = f.readlines()[secs[2][1]:secs[4][1]-1]
            T_fill.append('\n')

        with open(self.VBO_FILE_NAME, 'r') as f:
            T_columns = f.readlines()[secs[4][1]:secs[5][1]+1]
            if 'Channel_1' in vbo.columns:
                T_columns[1] = T_columns[1][:-2]+' UTC_Time OffsetToCL OffsetToCL_filt AccelLateral_filt Steering_Angle\n'
            else:
                T_columns[1] = T_columns[1][:-2]+' UTC_Time OffsetToCL OffsetToCL_filt AccelLateral_filt\n'

        with open('vbo.csv', 'r') as f:
            data = f.readlines()

        with open(TARGET_FILE_NAME, 'w') as f:
            for l in T_header:
                f.write(l)
            for l in T_channel_units:
                f.write(l)
            for l in T_fill:
                f.write(l)
            for l in T_columns:
                f.write(l)
            for l in data:
                f.write(l)
        
        msg = QMessageBox()
        msg.setWindowTitle("Accomplished")
        msg.setText('New file:' + TARGET_FILE_NAME)
        msg.setIcon(QMessageBox.Information)
        msg.exec_()


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())
